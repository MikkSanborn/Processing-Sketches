
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 * This class accepts two inputs (and has a bias) and 
 * represents a single-layer perceptron neural network.
 * It can be trained to recognize linear separable patterns
 * where there are only two input variables and one output.
 * The output is simply 1 or 0 but the inputs can be any real #s.
 * @author Mike
 *
 */
class TwoInputPerceptron {
  
  /**weights for two inputs and the biases*/
  private double w1, w2, wb;
  
  /**The learning rate determines a speed or step-size that is
   * used when correcting the weights.
   */
  public double learningRate = 0.1;
  
  /** provides random weights w such that 0 <= w < 1 */
  public TwoInputPerceptron() {
    w1 = Math.random();
    w2 = Math.random();
    wb = Math.random();
  }
  
  /** returns 1 if w1*in1 + w2*in2 + wb is greater than 0
   *  where w1, w2, and wb are the weights for the neuron
   */
  public double getOutput(double in1, double in2) {
    if(in1*w1 + in2*w2 + wb > 0)
      return 1;
    else 
      return 0;
  }
  
  public String toString() {
    return "Weights (w1, w2, wb): (" + w1 + ", " + w2 +
        ", " + wb + ")";
  }
  
  /**Send training data...x1 and x2 should produce desiredOut
   * This method uses the training data to adjust the weights.
   */ 
  public void train(double x1, double x2, double desiredOut) {
    //Predict output from current network
    double actualOut = getOutput(x1, x2);
    
    //calculate error term. For this code, error should be -1, 0, or 1
    //since the output (actual and desired) is always a 0 or 1
    double error = desiredOut - actualOut;
    
    //The change in weight is given by:
    //   (error term)(associated input)(learningRate)
    //Recall that the bias has an "input" of 1
    w1 += error*x1*learningRate;
    w2 += error*x2*learningRate;
    wb += error*1*learningRate;
  }
  
  
  
/////////////////////////////////////////////////////////////////////
//  BELOW IS JUST SOME HACK AT VISUALIZING A GRAPH OF THE 
//  BOUNDARY LINE THAT THIS PERCEPTRON CREATES...VISUALIZE
//  THE LINEAR SEPARABILITY
/////////////////////////////////////////////////////////////////////
  
  
  //size of graph from l-to-r or t-to-b in real world units
  //so if this number is 2 then graph goes from -1 to 1
  //RWU is real-world-units
  public double GRAPH_DIMENSION_RWU = 4;
  /** Quick method to show a graph of the line generated by this
   * 2-input perceptron...demonstrate linear separability.
   */
  @SuppressWarnings("serial")
  public void showGraph() {
    JFrame frame = new JFrame();
    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    final int frameSize = 500;
    frame.setSize(frameSize, frameSize + 50);
    frame.getContentPane().add(new JPanel() {
      public void paintComponent(Graphics g) {
        g.setColor(Color.BLACK);
        g.drawLine(frameSize/2, 0, frameSize/2, frameSize);
        g.drawLine(0, frameSize/2, frameSize, frameSize/2);
        
        //find rwu for point on RHS edge of graph
        double t1x1 = GRAPH_DIMENSION_RWU/2;
        double t1x2 = (-wb -w1*t1x1)/w2;
        
        //find rwu for point on TOP edge of graph
        double t2x2 = GRAPH_DIMENSION_RWU/2;
        double t2x1 = (-wb - w2*t2x2)/w1;
        
        //find rwu for point on BOTTOM edge of graph
        double t3x2 = -GRAPH_DIMENSION_RWU/2;
        double t3x1 = (-wb - w2*t3x2)/w1;
        
        int p1x1 = frameSize;
        int p1x2 = (int)(frameSize/2 - t1x2/(GRAPH_DIMENSION_RWU/2) * frameSize/2);
        
        int p2x2 = 0;
        int p2x1 = (int)(frameSize/2 + t2x1/(GRAPH_DIMENSION_RWU/2) * frameSize/2);
        
        int p3x2 = 500;
        int p3x1 = (int)(frameSize/2 + t3x1/(GRAPH_DIMENSION_RWU/2) * frameSize/2);
        
        
        //being paranoid...really lazy attempt at being lazy
        g.drawLine(p1x1, p1x2, p2x1, p2x2);
        g.drawLine(p1x1, p1x2, p3x1, p3x2);
        g.drawLine(p2x1, p2x2, p3x1, p3x2);
        
//        System.out.println("Points graphed: (" + p1x1 + ", " + p1x2 + ") and (" + p2x1 + ", " + p2x2 + ")");
        
        //drawing points at (1,0), (0,1), and (1,1)
        g.setColor(Color.RED);
        int dotRadius = 5;
        g.fillOval(frameSize/2 + (int)(1/(GRAPH_DIMENSION_RWU/2)*(frameSize/2)) -dotRadius, frameSize/2 - dotRadius, 2*dotRadius, 2*dotRadius);
        g.fillOval(frameSize/2 - dotRadius, frameSize/2 - (int)(1/(GRAPH_DIMENSION_RWU/2)*(frameSize/2)) -dotRadius, 2*dotRadius, 2*dotRadius);
        g.fillOval(frameSize/2 + (int)(1/(GRAPH_DIMENSION_RWU/2)*(frameSize/2)) -dotRadius, frameSize/2 - (int)(1/(GRAPH_DIMENSION_RWU/2)*(frameSize/2)) -dotRadius, 2*dotRadius, 2*dotRadius);
        
      }
    });

    frame.setVisible(true);
    
  }
  
  
}
